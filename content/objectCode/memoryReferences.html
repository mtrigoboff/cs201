<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!-- InstanceBegin template="/Templates/content.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Memory References</title>
<!-- InstanceBeginEditable name="head" --><!-- InstanceEndEditable -->
<!-- template parameters -->


<!-- InstanceParam name="homeDirectory" type="text" value="" -->





<!-- InstanceParam name="topicName" type="text" value="Memory References" -->
<style type="text/css">
<!--
body {
	background-color: #FFFFFF;
	font-size: 16px;
	color: #000000;
	font-family: Cambria, "Times New Roman", serif;
}
table {
	background-color: #EEEEEE;
}
a:link {
	color: #000099;
}
a:visited {
	color: #000066;
}
a:hover {
	color: #FF0000;
}
.calendarDate {
	text-align: center;
	vertical-align: middle;
}
.code {
	font-family: Consolas, "Courier New", mon;
	font-size: 12px;
}
.codeInText {
	font-family: Consolas, "Courier New", mon;
	font-size: 14px;
}
.codeBlue {
	color: #000099;
	font-family: Consolas, "Courier New", mono;
	font-size: 12px;
}
.headerText {
	font-size: 24px;
	color: #000000;
	text-decoration: underline;
}
.headerText2 {
	font-size: 18px;
	color: #000000;
	text-decoration: underline;
	font-weight: normal;
}
.headerText3 {

	font-size: 16px;
	color: #000000;
	text-decoration: underline;
}
.pageHeaderText {
	font-size: 36px;
	color: #000000;
}
.red {
  color: #FF0000
}
-->
</style>
</head>

<body>
<blockquote>
  <p><span class="pageHeaderText">CS201: Memory References</span></p>
</blockquote>
<hr />

<blockquote>
<!-- InstanceBeginEditable name="content" -->
<p>In AT&amp;T format, memory references have the following form:</p>
<blockquote>
	<p class="codeInText">offset(baseReg,indexReg,scale)	 </p>
</blockquote>
<p>An address is computed from these components as follows:</p>
<blockquote>
	<p class="codeInText">address = offset + baseReg + indexReg * scale  </p>
	</blockquote>
<p><span class="codeInText">scale</span> can be one of the following values: 1, 2, 4, 8. (Future enhancements to the IA-32 architecture may include higher values for <span class="codeInText">scale</span>, such as 16, 32, etc.) </p>
<p>In Intel format, a 32-bit memory reference looks like this:</p>
<blockquote>
	<p class="codeInText">DWORD PTR [baseReg+indexReg*scale+offset] </p>
	</blockquote>
<p>A 64-bit value would <span class="codeInText">QWORD</span> instead of <span class="codeInText">DWORD</span>. A 16-bit value would say <span class="codeInText">WORD</span>. An 8-bit value would say <span class="codeInText">BYTE</span>. </p>
<p><em>Note: not every component of the formulas above will always be present in a particular memory reference. You may see memory references that lack one or more of them. Here are a few examples of valid (but &ldquo;incomplete&rdquo;) memory references:</em></p>
<blockquote>
	<p class="codeInText">offset</p>
	<p class="codeInText">offset(baseReg)</p>
	<p class="codeInText">(baseReg)</p>
</blockquote>
<p><strong>array.c</strong> computes and prints out the sum of the elements of an array using an <em>index</em> to iterate through the array. Compile array.c in Linux, and run the code in<strong> gdbtui</strong>. Look at the code in MIXED mode, so that you see the object code as well as the source code. </p>
<p>Set<strong> gdbtui </strong>to display in both AT&amp;T and Intel modes. Look at the instruction at <span class="codeInText">&lt;main+93&gt;</span> and observe how the memory reference changes from one form to the other. </p>
<p>Note how the offset appears as <span class="codeInText">-24</span> in Intel mode and <span class="codeInText">0xffffffe8</span> in AT&amp;T mode. Note how the opcode <span class="codeInText">mov</span> in Intel mode becomes <span class="codeInText">movl</span> in AT&amp;T mode. </p>
<p><strong>array2.c</strong> shows a different way of summing the elements of an array, using a <em>pointer</em> instead of an <em>index</em>. In the &ldquo;old days,&rdquo; coding a loop this way was a mark of skill, because it would compile into faster code than the indexed version. Modern optimizing compilers have made it unnecessary in most cases to hand-code for efficiency like this. Look at the object code for array2.c and compare the instructions compiled for the assignment statement in the loop with what was compiled for the equivalent statement in array.c.</p>
<p>&nbsp;</p>
<!-- InstanceEndEditable -->
</blockquote>
</body>
<!-- InstanceEnd --></html>
